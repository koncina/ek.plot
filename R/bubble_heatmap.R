NULL

#' @importFrom grid grid.circle gpar
draw_bubble <- function(m, m_prop,
                        contour = \(x) "black",
                        fill = \(x) NA,
                        dot_scale = 0.9,
                        contour_max_gp) {

  function(j, i, x, y, width, height, fill) {

    # Not sure this is the best way but it works
    # width and height are in npc
    # I had troubles to set the expected size
    # when splitting columns and or rows...

    r <- (if (convertHeight(height, "mm", valueOnly = TRUE) <
              convertWidth(width, "mm", valueOnly = TRUE))
      convertHeight(height, "mm") else
        convertWidth(width, "mm") ) / 2


    grid.circle(x = x,
                y = y,
                r = m_prop[i, j] * dot_scale * r,
                gp = gpar(col = contour(m[i, j]),
                          fill = fill(m[i, j])
                ))

    if (!any(is.na(c(m[i, j], m_prop[i, j])))) {
      grid.circle(x = x,
                  y = y,
                  r = dot_scale * r,
                  gp = contour_max_gp
      )
    }

  }
}

#' Draw a bubble heatmap.
#'
#' @importFrom tidyr pivot_wider
#' @importFrom tibble column_to_rownames
#' @importFrom tidyselect eval_select
#' @importFrom rlang enquo as_name
#' @importFrom ComplexHeatmap Heatmap
#'
#' @param data A tibble containing a "long version" of values and proportions
#' @param row,column The variables to be used as columns and rows to represent the matrix
#' @param colour,size The variables that will be mapped to the heatmap colour intensity and the dot size
#' @param row_key,column_key An optional variable to split the columns and rows (groups)
#' @param colour_scale A colour mapping function such as generated by \code{circlize::colorRamp2}.
#' @param dot_size The maximum size of the dot/cell of the heatmap.
#' @param dot_scale A scaling factor to avoid dots to touch each other (defaults to 0.9).
#' @param contour,fill If TRUE uses the colour_scale for the contour and/or the fillin. Otherwise a colour (character).
#' @param contour_max_gp Graphical parameter of the maximum contour line (defaults to a gray line)
#' @param rect_gp passed to the rect_gp argument of ComplexHeatmap: Should be usualy set to \code{gpar(type = "none")}
#' @param ... Other arguments passed to \code{ComplexHeatmap::Heatmap}
#' @return a ComplexHeatmap
#' @export
bubble_heatmap <- function(data,
                           row, column,
                           colour, size,
                           row_key = NULL,
                           column_key = NULL,
                           dot_size = unit(5, "mm"),
                           dot_scale = 0.9,
                           contour = TRUE,
                           fill = TRUE,
                           colour_scale = circlize::colorRamp2(
                             breaks = c(-2, 0, 2),
                             colors = c("#377EB8", "white", "#E41A1C")
                           ),
                           contour_max_gp = gpar(col = "gray", fill = NA, lty = 1),
                           rect_gp = gpar(type = "none"),
                           ...) {

  m <-  pivot_wider(data,
                    names_from = {{column}},
                    values_from = {{colour}},
                    id_cols = {{row}}) |>
    column_to_rownames(as_name(enquo(row))) |>
    as.matrix()

  m_prop <- pivot_wider(data,
                        names_from = {{column}},
                        values_from = {{size}},
                        id_cols = {{row}}) |>
    column_to_rownames(as_name(enquo(row))) |>
    as.matrix()

  n_column_keys <- length(eval_select(enquo(column_key), data))
  n_row_keys <- length(eval_select(enquo(row_key), data))

  stopifnot(n_column_keys <= 1 && n_row_keys <= 1)

  if (n_column_keys > 0) {
    column_key <- distinct(data, {{column}}, {{column_key}}) |>
      deframe()
  }

  if (n_row_keys > 0) {
    row_key <- distinct(data, {{row}}, {{row_key}}) |>
      deframe()
  }

  Heatmap(m,
          name = "z-score",
          col = colour_scale,
          rect_gp = {{rect_gp}},
          cell_fun = draw_bubble(m, m_prop,
                                 contour = if (isTRUE({{contour}})) {{colour_scale}} else \(x) {{contour}},
                                 fill = if (isTRUE({{fill}})) {{colour_scale}} else \(x) {{fill}},
                                 dot_scale = {{dot_scale}}, contour_max_gp = {{contour_max_gp}}),
          column_split = column_key,
          row_split = row_key,
          width = ncol(m) * dot_size,
          height = nrow(m) * dot_size,
          ...)
}
